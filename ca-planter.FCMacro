import FreeCAD as App
import FreeCADGui
import Part
import math
import random
import PySide
from datetime import datetime

# Get the current date and time
now = datetime.now()
timestamp = now.strftime("%Y%m%d_%H%M%S")  # Format: YYYYMMDD_HHMMSS

# Parameters
rng_seed = 0 # Seed for random number generator. allows repeatable output. Change to vary the result
cells = 330  # Circumferential resolution (number of cells per row)
height = 100 # Height of planter 
outer_diameter = 120  # Outer radius of the planter
wall_thickness = 1.2  # Thickness of the walls - ideally a multiple of the line width of your printer
cell_thickness = 2.4  # Protrusion of the cells from the planter surface
rule_number = 110  # Cellular Automaton rule (adjust this for different rules) - 0-255. 30 and 110 are probably the most interesting
overlap_thickness = 0.3  # Thickness of the overlap between the cells and the outer cylinder
base_depth = 5  # Depth of the base of the planter
base_thickness = 3  # Thickness of the base
base_fillet = 3  # Fillet radius of the base
drain_hole_diameter = 30  # Diameter of the drain hole
combine = False  # Combine all cells into a single shape (True) or keep them separate (False). Combining is much slower to generate, but the output has multiple parts
step_file_path = f"A:\\Personal\\code-workspace\\cellular-automaton-planter\\ca-planter-{timestamp}-D{outer_diameter}H{height}-C{cells}-R{rule_number}-S{rng_seed}.step" # Specify the file path where you want to save the STEP file

# Computed parameters
outer_radius = outer_diameter / 2  # Outer radius of the planter
circumference = 2 * math.pi * (outer_radius + cell_thickness)

# Calculate number of steps so that cells are close to square
cell_size = circumference / cells  # Size of each CA cell (square cells, so this is width and height)

height_wo_base = height - base_depth  # Adjust height to exclude the base
steps = int(height_wo_base / cell_size)  # Adjust number of steps (height) based on cell size

print(f"Cell size: {cell_size}")
print(f"Number of generations: {steps}")


# Generate the rule's binary representation
rule_bin = "{0:08b}".format(rule_number)  # Convert rule number to binary (8 bits)

# Function to apply any rule (generic based on rule number)
def apply_rule(a, b, c):
    # Convert the triplet (a, b, c) to a binary index
    index = (a << 2) | (b << 1) | c
    # Return the corresponding bit in the rule's binary string
    return int(rule_bin[7 - index])

# Generate initial state (random, alternating, or custom)
# alternating initial state
#initial_state = [i % 2 for i in range(cells)]
# random initial state
random.seed(rng_seed)
initial_state = [random.randint(0, 1) for i in range(cells)]

# Create document
doc = App.newDocument("CA_Planter_General")

# show the origin
origin = App.ActiveDocument.addObject("App::Origin", "Origin")
origin.ViewObject.Visibility = True

# Create basic cylinder of planter, including base
modified_base_depth = height - steps * cell_size # Adjust base depth to give correct height
print(f"Modified base depth: {modified_base_depth}")
outer_cylinder = Part.makeCylinder(outer_radius + overlap_thickness, height)
outer_cylinder.translate(App.Vector(0, 0, -modified_base_depth))
# Select the lowest edge by checking Z coordinates
edges = outer_cylinder.Edges
lowest_edge = min(edges, key=lambda e: e.Vertexes[0].Point.z)  # Edge with lowest Z value
outer_cylinder = outer_cylinder.makeFillet(base_fillet, [lowest_edge])
#planter = outer_cylinder.fuse(base)

inner_cylinder = Part.makeCylinder(outer_radius - wall_thickness, height - base_thickness)
inner_cylinder.translate(App.Vector(0, 0, -modified_base_depth + base_thickness))
planter = outer_cylinder.cut(inner_cylinder)

drain_hole = Part.makeCylinder(drain_hole_diameter / 2, base_thickness)
drain_hole.translate(App.Vector(0, 0, -modified_base_depth))

planter = planter.cut(drain_hole)

# Generate CA and extrude shapes for each active cell
state = initial_state

# Add a progress dialog - this helps when generating large models
pd = PySide.QtGui.QProgressDialog(u"Generating", u"Abort", 0, steps)
pd.setModal(True)

# loop through generations
for z in range(steps):
    
    #print(f"Step {z}")
    print("".join([str(s) for s in state]))
    sketches = []
    next_state = []

    # 2. Create a new sketch and attach it to the XY plane
    # Note that a separate sketch is created for each generation to ensure that open cells do not form connected boundaries across generations
    # This is important for the Part Extrude operation to work correctly
    sketch = doc.addObject('Sketcher::SketchObject', f'Planter_Sketch_{z}')
    sketches.append(sketch)
    sketch.Support = [(doc.getObject('XY_Plane'), '')]

    # 3. Generate a bounding box in construction geometry
    bounding_width = outer_diameter * math.pi
    bounding_height = height

    # Add the bounding box as construction lines (vertical and horizontal) - used for sketch on surface
    sketch.addGeometry(Part.LineSegment(App.Vector(0, 0, 0), App.Vector(bounding_width, 0, 0)), True)  # Bottom
    sketch.addGeometry(Part.LineSegment(App.Vector(0, 0, 0), App.Vector(0, bounding_height, 0)), True)  # Left
    sketch.addGeometry(Part.LineSegment(App.Vector(0, bounding_height, 0), App.Vector(bounding_width, bounding_height, 0)), True)  # Top
    sketch.addGeometry(Part.LineSegment(App.Vector(bounding_width, 0, 0), App.Vector(bounding_width, bounding_height, 0)), True)  # Right

    # loop through cells in a generation
    for s in range(cells):
        # Get the three neighboring cells
        left = state[(s - 1) % cells]
        center = state[s]
        right = state[(s + 1) % cells]
        
        # Apply the rule to determine the next state
        next_state.append(apply_rule(left, center, right))
        
        # If current cell is active, add a cube at the appropriate position

        if state[s] == 1:
            # location to make cell
            x_pos = s * cell_size
            y_pos = z * cell_size
            # Add cell to the sketch
            sketch.addGeometry(Part.LineSegment(App.Vector(x_pos, y_pos, 0), App.Vector(x_pos + cell_size, y_pos, 0)))  # Bottom
            sketch.addGeometry(Part.LineSegment(App.Vector(x_pos, y_pos, 0), App.Vector(x_pos, y_pos + cell_size, 0)))  # Left
            sketch.addGeometry(Part.LineSegment(App.Vector(x_pos + cell_size, y_pos, 0), App.Vector(x_pos + cell_size, y_pos + cell_size, 0)))  # Right
            sketch.addGeometry(Part.LineSegment(App.Vector(x_pos, y_pos + cell_size, 0), App.Vector(x_pos + cell_size, y_pos + cell_size, 0)))  # Top
    
    # Update state for the next generation
    state = next_state
    pd.setValue(z)
    if pd.wasCanceled():
        raise Exception("Canceled by user")

pd.setValue(steps)
print("finished")

# Display the result 
Part.show(planter)
doc.recompute()

# Set view to isometric
gui_doc = FreeCADGui.ActiveDocument
gui_doc.activeView().viewIsometric()


# Fit the view to the whole object
gui_doc.activeView().fitAll()

# Select all shapes for export 
parts_to_export = [obj for obj in doc.Objects if hasattr(obj, 'Shape')]

# Create a selection object
FreeCADGui.Selection.clearSelection()  # Clear any previous selection
for obj in parts_to_export:
    FreeCADGui.Selection.addSelection(obj)

# Export the selected objects to a STEP file
Part.export(FreeCADGui.Selection.getSelection(), step_file_path)

print(f"Exported to {step_file_path}")