import FreeCAD as App
import FreeCADGui
import Part
import math
import random
import PySide
from datetime import datetime

# TODO: possible optimisations: 
# TODO: possible off-by-one error in the number of generations - check the height calculation
# TODO: check offset between extruded cells and surface - may need to add an offset to the sketch on surface
# TODO: add more options for initial state (e.g., random, alternating, custom)

# Get the current date and time
now = datetime.now()
timestamp = now.strftime("%Y%m%d_%H%M%S")  # Format: YYYYMMDD_HHMMSS

# Parameters
rng_seed = 0 # Seed for random number generator. allows repeatable output. Change to vary the result
cells = 330  # Circumferential resolution (number of cells per row)
height = 100 # Height of planter 
outer_diameter = 120  # Outer radius of the planter
wall_thickness = 1.2  # Thickness of the walls - ideally a multiple of the line width of your printer
cell_thickness = 2.4  # Protrusion of the cells from the planter surface
rule_number = 30  # Cellular Automaton rule (adjust this for different rules) - 0-255. 30 and 110 are probably good choices
# suggested rules to try: 30, 45, 54, 60, 62, 73, 90, 94, 102, 105, 106, 110, 122, 126, 150, 158, 182
overlap_thickness = 0.3  # Thickness of the overlap between the cells and the outer cylinder
base_depth = 5  # Depth of the base of the planter
base_thickness = 3  # Thickness of the base
base_fillet = 3  # Fillet radius of the base
drain_hole_diameter = 30  # Diameter of the drain hole
step_file_path = f"A:\\Personal\\code-workspace\\cellular-automaton-planter\\ca-planter-{timestamp}-D{outer_diameter}H{height}-C{cells}-R{rule_number}-S{rng_seed}.step" # Specify the file path where you want to save the STEP file

# Computed parameters
outer_radius = outer_diameter / 2  # Outer radius of the planter
circumference = 2 * math.pi * outer_radius

# Calculate number of steps so that cells are close to square
cell_size = circumference / cells  # Size of each CA cell (square cells, so this is width and height)

height_wo_base = height - base_depth  # Adjust height to exclude the base
steps = int(height_wo_base / cell_size)  # Adjust number of steps (height) based on cell size

print(f"Cell size: {cell_size}")
print(f"Number of generations: {steps}")


# Generate the rule's binary representation
rule_bin = "{0:08b}".format(rule_number)  # Convert rule number to binary (8 bits)

# Function to apply any rule (generic based on rule number)
def apply_rule(a, b, c):
    # Convert the triplet (a, b, c) to a binary index
    index = (a << 2) | (b << 1) | c
    # Return the corresponding bit in the rule's binary string
    return int(rule_bin[7 - index])

# Generate initial state (random, alternating, or custom)
# alternating initial state
#initial_state = [i % 2 for i in range(cells)]
# random initial state
random.seed(rng_seed)
initial_state = [random.randint(0, 1) for i in range(cells)]

# Create document
doc = App.newDocument("CA_Planter_General")
# Set view to isometric
gui_doc = FreeCADGui.ActiveDocument
gui_doc.activeView().viewIsometric()

# show the origin
origin = App.ActiveDocument.addObject("App::Origin", "Origin")
origin.ViewObject.Visibility = True

# Create basic cylinder of planter, including base
modified_base_depth = height - steps * cell_size # Adjust base depth to give correct height
print(f"Modified base depth: {modified_base_depth}")
outer_cylinder = Part.makeCylinder(outer_radius, height)
outer_cylinder.translate(App.Vector(0, 0, -modified_base_depth))

# Select the lowest edge by checking Z coordinates
edges = outer_cylinder.Edges
lowest_edge = min(edges, key=lambda e: e.Vertexes[0].Point.z)  # Edge with lowest Z value
outer_cylinder = outer_cylinder.makeFillet(base_fillet, [lowest_edge])
#planter = outer_cylinder.fuse(base)

inner_cylinder = Part.makeCylinder(outer_radius - wall_thickness, height - base_thickness)
inner_cylinder.translate(App.Vector(0, 0, -modified_base_depth + base_thickness))
planter = outer_cylinder.cut(inner_cylinder)

drain_hole = Part.makeCylinder(drain_hole_diameter / 2, base_thickness)
drain_hole.translate(App.Vector(0, 0, -modified_base_depth))

planter = planter.cut(drain_hole)
planter_obj = doc.addObject("Part::Feature", "Planter")
planter_obj.Shape = planter

# Fit the view to the whole object
gui_doc.activeView().fitAll()

# Generate CA 
print("Generating CA")
state = initial_state

# Add a progress dialog for long running operations
pd = PySide.QtGui.QProgressDialog(u"Generating CA", u"Abort", 0, steps)
pd.setModal(True)

for z in range(steps):
    print(f"Step {z} of {steps}")
    print("".join([str(s) for s in state]))
    next_state = []

    # loop through cells in a generation
    for s in range(cells):
        # Get the three neighboring cells
        left = state[(s - 1) % cells]
        center = state[s]
        right = state[(s + 1) % cells]
        
        # Apply the rule to determine the next state
        next_state.append(apply_rule(left, center, right))
    
    # Update state for the next generation
    state = next_state
    pd.setValue(z)
    if pd.wasCanceled():
        raise Exception("Canceled by user")

pd.setValue(steps)

# Generate sketches ==============================================
print("Generating sketches")
pd = PySide.QtGui.QProgressDialog(u"Generating sketches", u"Abort", 0, steps)
pd.setModal(True)

# Generate a bounding box in construction geometry - this is required for the projection to surface
bounding_width = outer_diameter * math.pi
bounding_height = height_wo_base

# optimisation: reduce number of sketches: use 2 sketches, with alternating generations
sketches = []

# create a base sketch for each
for z in range(2):
    # Create a new sketch and attach it to the XY plane
    # Note that a separate sketch is created for each generation to ensure that open cells do not form connected boundaries across generations
    # This is important for the Part Extrude operation to work correctly
    sketch = doc.addObject('Sketcher::SketchObject', f'Planter_Sketch_{z}')
    sketches.append(sketch)
    sketch.Support = [(doc.getObject('XZ_Plane'), '')]
    sketch.Visibility = True  

    # Add the bounding box as construction lines (vertical and horizontal) - used for sketch on surface
    sketch.addGeometry(Part.LineSegment(App.Vector(0, 0, 0), App.Vector(bounding_width, 0, 0)), True)  # Bottom
    sketch.addGeometry(Part.LineSegment(App.Vector(0, 0, 0), App.Vector(0, bounding_height, 0)), True)  # Left
    sketch.addGeometry(Part.LineSegment(App.Vector(0, bounding_height, 0), App.Vector(bounding_width, bounding_height, 0)), True)  # Top
    sketch.addGeometry(Part.LineSegment(App.Vector(bounding_width, 0, 0), App.Vector(bounding_width, bounding_height, 0)), True)  # Right

# loop through generations
for z in range(steps):
    sketch_index = z % 2
    sketch = sketches[sketch_index]

    print(f"Step {z} of {steps}")
    print("".join([str(s) for s in state]))
    next_state = []


    # loop through cells in a generation
    for s in range(cells):
        # Get the three neighboring cells
        left = state[(s - 1) % cells]
        center = state[s]
        right = state[(s + 1) % cells]
        
        # Apply the rule to determine the next state
        next_state.append(apply_rule(left, center, right))
        
        # Create a cell if the current state is active
        if center == 1:
            # location to make cell
            x_pos = s * cell_size
            y_pos = z * cell_size
            # Add cell to the sketch
            # optimisation: reduce number of extrusions by combining cells into a single shape within the sketch
            # - examine the state of the previous cell - if it is also active, then don't include the boundary between cells 
            if left == 0 or s == 0:
                sketch.addGeometry(Part.LineSegment(App.Vector(x_pos, y_pos, 0), App.Vector(x_pos, y_pos + cell_size, 0)))  # Left
            # optimisation: reduce number of extrusions by combining cells into a single shape within the sketch
            # - examine the state of the next cell - if it is also active, then don't include the boundary between cells 
            if right == 0 or s == cells - 1:
                sketch.addGeometry(Part.LineSegment(App.Vector(x_pos + cell_size, y_pos, 0), App.Vector(x_pos + cell_size, y_pos + cell_size, 0)))  # Right
            
            # - reduce number of extrusions: combine cells into a single shape within the sketch
            #   - only draw the top and bottom lines if the cell is the last adjacent cell before an inactive cell, or if it is on the boundary
            if left == 0 or s == 0:
                min_x = x_pos
            
            if right == 0 or s == cells - 1:
                sketch.addGeometry(Part.LineSegment(App.Vector(min_x, y_pos, 0), App.Vector((s+1) * cell_size, y_pos, 0)))  # Bottom
                sketch.addGeometry(Part.LineSegment(App.Vector(min_x, y_pos + cell_size, 0), App.Vector((s+1) * cell_size, y_pos + cell_size, 0)))  # Top

    
    # Now perform sketch to surface
    # Make the support the face of the cylinder
    print(planter_obj)
    sketch.Support = (planter_obj, u'Face1')

    # Update state for the next generation
    state = next_state
    pd.setValue(z)
    if pd.wasCanceled():
        raise Exception("Canceled by user")

pd.setValue(steps)
gui_doc.activeView().fitAll()

# raise Exception("Debug - sketches generated")

# Wrapping =============================================
print("Wrapping")
FreeCADGui.activateWorkbench("CurvesWorkbench")

# progress dialog for wrapping stage
pd = PySide.QtGui.QProgressDialog(u"Wrapping", u"Abort", 0, len(sketches))
pd.setModal(True)

# loop through sketches
for i, sketch in enumerate(sketches):
    print(i)
    FreeCADGui.Selection.clearSelection()
    # Select the sketch and surface
    FreeCADGui.Selection.addSelection(sketch)
    FreeCADGui.Selection.addSelection(planter_obj, 'Face1')

    # Run Sketch On Surface (SoS command)
    FreeCADGui.runCommand('SoS', 0)

    sketch.Visibility = True # show the sketch

    pd.setValue(i)
    if pd.wasCanceled():
        raise Exception("Canceled by user")

pd.setValue(len(sketches))
print("finished wrapping")

# Get all objects in the document and find the last created Sketch On Surface object
sos_objects = [obj for obj in doc.Objects if obj.Label.startswith("Sketch_On_Surface")]
num_sos = len(sos_objects)
print(f"Number of Sketch On Surface objects: {num_sos}")

# Extrude the cells ==============================================
print("Extruding cells")
pd = PySide.QtGui.QProgressDialog(u"Extruding cells", u"Abort", 0, num_sos)
pd.setModal(True)
for i, sos in enumerate(sos_objects):
    print(f"Extruding sketch {i} of {num_sos}")
    # add thickness
    sos.Thickness = cell_thickness
    #add fill
    sos.FillFaces = True
    pd.setValue(i)
    if pd.wasCanceled():
        raise Exception("Canceled by user")

pd.setValue(num_sos)
print("finished extruding")

# Display the result 
doc.recompute()

#raise Exception("Stopped here")
# Select all shapes for export 
parts_to_export = [obj for obj in doc.Objects if hasattr(obj, 'Shape')]

# Create a selection object
FreeCADGui.Selection.clearSelection()  # Clear any previous selection
for obj in parts_to_export:
    FreeCADGui.Selection.addSelection(obj)

# Export the selected objects to a STEP file
Part.export(FreeCADGui.Selection.getSelection(), step_file_path)

print(f"Exported to {step_file_path}")
end = datetime.now()
print(f"Time taken: {end - now}")